CSE 331 Homework 3.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Anina Harriott

Problem 6.

(a) Fibonacci failed the testThrowsIllegalArgumentException test because the code designated the input of 0 as a
    negative number and threw an exception for that, however 0 is not negative and therefore not an invalid input
    that needs an exception thrown. All I changed was the condition in the if statement for the
    IllegalArgumentException, I altered it to if(n < 0) instead of if(n <= 0).

(b) Fibonacci failed the testBaseCase test because it threw an exception when passed the base case input of 0 when
    it should have returned 1. The modifications I made to fix the testThrowsIllegalArgumentException test were
    sufficient to also fix this test, the if statement before the IllegalArgumentException was altered to if(n < 0)
    instead of if(n <= 0).

(c) Fibonacci failed the testInductiveCase test because the else/if condition and the math in the else statement were
    not returning the desired term in the Fibonacci sequence. To fix this I changed the else/if condition to
    else if (n < 2) instead of else if (n <= 2), and I changed the return statement to add the two recursive calls
    of getFibTerm instead of subtracting them.

Problem 7. 

    Ball
    The problems with Ball.java were that a variable and a field were both named volume, and the method getVolume()
    was always returning 0 instead of that objects volume. I changed the variable referring to a volume to vol and
    left the field as volume. I changed the method getVolume() to return volume.

    BallContainer
    I think the second approach to getVolume() for BallContainer is better (keeping track of the total volume) because
    it gets rid of repeated computations and reduces the complexity of the method, so it truly just gets the volume.

    Box
    1. The two ways I thought of implementing getBallsFromSmallest() was to either create a field for an array in the
    constructor and add and remove Ball objects from the array to match the ballContainer, or create a local variable
    array in the getBallsFromSmallest() and add all the current Ball objects from ballContainer to it. Then in both of
    those implementations I would create a comparator in getBallsFromSmallest() and then sort the array and return an
    iterator of it.
    2. I think the implementation where the array is only a local variable is better because adding and removing from
    the array constantly would be very redundant code when the ballContainer already has all of that information. I
    think it makes the code more concise, and the array really only needs to be used in getBallsFromSmallest().